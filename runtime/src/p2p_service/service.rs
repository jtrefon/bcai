//! Defines the core `P2PService` and its main event loop.

use super::{
    behaviour::{BCAIBehaviourEvent, BCAINetworkBehaviour},
    codec::WireMessage,
    command::{Command, P2PHandle},
    config::P2PConfig,
    error::P2PError,
    types::{PeerInfo, P2PStats},
};
use futures::StreamExt;
use libp2p::{
    gossipsub, identity, kad,
    request_response::{self, ProtocolSupport},
    swarm::{Swarm, SwarmEvent},
    Multiaddr, PeerId,
};
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::sync::{mpsc, oneshot};

const GLOBAL_TOPIC: &str = "bcai_global";

/// The main P2P service struct. It owns the libp2p Swarm and handles all
/// network events and application-level commands.
pub struct P2PService {
    pub swarm: Swarm<BCAINetworkBehaviour>,
    pub command_receiver: mpsc::Receiver<Command>,
    peers: HashMap<String, PeerInfo>,
    stats: P2PStats,
    start_time: Option<Instant>,
    config: P2PConfig,
    request_map: HashMap<
        request_response::RequestId,
        oneshot::Sender<Result<WireMessage, P2PError>>,
    >,
}

impl P2PService {
    /// Create a new P2P service, which includes the service itself and a handle for interaction.
    pub async fn new(config: P2PConfig) -> Result<(Self, P2PHandle), P2PError> {
        let local_key = identity::Keypair::generate_ed25519();
        let local_peer_id = PeerId::from(local_key.public());
        println!("ðŸ¤– Local Peer ID: {}", local_peer_id);

        let transport = libp2p::tcp::tokio::Transport::new(libp2p::tcp::Config::default())
            .upgrade(libp2p::core::upgrade::Version::V1)
            .authenticate(
                libp2p::noise::Config::new(&local_key)
                    .map_err(|e| P2PError::TransportError(e.to_string()))?,
            )
            .multiplex(libp2p::yamux::Config::default())
            .boxed();

        let gossipsub_config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(10))
            .build()
            .map_err(|s| P2PError::ConnectionFailed(s.to_string()))?;

        let gossipsub = gossipsub::Behaviour::new(
            gossipsub::MessageAuthenticity::Signed(local_key.clone()),
            gossipsub_config,
        )
        .map_err(|s| P2PError::SerializationFailed(s.to_string()))?;

        let kademlia =
            kad::Behaviour::new(local_peer_id, kad::store::MemoryStore::new(local_peer_id));
        
        let request_response = request_response::Behaviour::new(
            [(super::codec::WireProtocol(), ProtocolSupport::Full)],
            request_response::Config::default(),
        );

        let behaviour = BCAINetworkBehaviour {
            gossipsub,
            kademlia,
            request_response,
        };

        let mut swarm = Swarm::with_tokio_executor(transport, behaviour, local_peer_id);
        let listen_addr = format!("/ip4/0.0.0.0/tcp/{}", config.listen_port);
        swarm.listen_on(listen_addr.parse().unwrap()).unwrap();

        let (command_sender, command_receiver) = mpsc::channel(32);
        let handle = P2PHandle::new(command_sender);
        
        // Subscribe to the global topic
        swarm
            .behaviour_mut()
            .gossipsub
            .subscribe(&gossipsub::IdentTopic::new(GLOBAL_TOPIC))
            .unwrap();


        let service = Self {
            swarm,
            command_receiver,
            peers: HashMap::new(),
            stats: P2PStats { // This should be moved to a `Default` impl
                peer_count: 0,
                connected_peers: 0,
                messages_sent: 0,
                messages_received: 0,
                bytes_sent: 0,
                bytes_received: 0,
                uptime: Duration::from_secs(0),
                network_stats: Default::default(),
            },
            start_time: Some(Instant::now()),
            config,
            request_map: HashMap::new(),
        };

        Ok((service, handle))
    }

    /// The main event loop of the P2P service.
    pub async fn run(mut self) {
        loop {
            tokio::select! {
                event = self.swarm.select_next_some() => {
                    self.handle_swarm_event(event).await;
                },
                Some(command) = self.command_receiver.recv() => {
                    self.handle_command(command).await;
                }
            }
        }
    }

    /// Handles events generated by the libp2p Swarm.
    async fn handle_swarm_event(&mut self, event: SwarmEvent<BCAIBehaviourEvent, libp2p::swarm::THandlerErr<BCAINetworkBehaviour>>) {
        match event {
            SwarmEvent::Behaviour(BCAIBehaviourEvent::Gossipsub(gossipsub::Event::Message {
                propagation_source: _,
                message_id: _,
                message,
            })) => {
                println!(
                    "Received gossipsub message: {:?}",
                    String::from_utf8_lossy(&message.data)
                );
            }
            SwarmEvent::Behaviour(BCAIBehaviourEvent::Kademlia(event)) => {
                // Handle Kademlia events, e.g., for peer discovery
            }
            SwarmEvent::Behaviour(BCAIBehaviourEvent::RequestResponse(
                request_response::Event::Message { peer, message },
            )) => {
                // Handle incoming request-response messages
            }
            SwarmEvent::NewListenAddr { address, .. } => {
                println!("Listening on {}", address);
            }
            SwarmEvent::ConnectionEstablished { peer_id, .. } => {
                println!("Connected to {}", peer_id);
            }
            _ => {}
        }
    }

    /// Handles commands sent from the application via the `P2PHandle`.
    async fn handle_command(&mut self, command: Command) {
        match command {
            Command::SendMessage { topic, message, response } => {
                let result = self.swarm.behaviour_mut().gossipsub.publish(topic, message)
                    .map(|_| ())
                    .map_err(|e| P2PError::SerializationFailed(e.to_string()));
                let _ = response.send(result);
            }
            Command::GetPeers { response } => {
                let peers = self.swarm.behaviour().kademlia.kbuckets().map(|b| b.iter().map(|e| *e.node.key.preimage()).collect()).flatten().collect();
                let _ = response.send(peers);
            }
            Command::Bootstrap { response } => {
                let result = self.swarm.behaviour_mut().kademlia.bootstrap()
                    .map(|_| ())
                    .map_err(|e| P2PError::Network(format!("Bootstrap failed: {:?}", e)));
                let _ = response.send(result);
            }
            Command::Request { peer_id, message, response } => {
                let request_id = self.swarm.behaviour_mut().request_response.send_request(&peer_id, message);
                self.request_map.insert(request_id, response);
            }
        }
    }
} 